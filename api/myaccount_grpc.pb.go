// Copyright Â© 2025 Prabhjot Singh Sethi, All Rights reserved
// Author: Prabhjot Singh Sethi <prabhjot.sethi@gmail.com>

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: myaccount.proto

package api

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	MyAccount_GetMyInfo_FullMethodName         = "/api.MyAccount/GetMyInfo"
	MyAccount_GetMySessions_FullMethodName     = "/api.MyAccount/GetMySessions"
	MyAccount_LogoutMySessions_FullMethodName  = "/api.MyAccount/LogoutMySessions"
	MyAccount_CreateApiKey_FullMethodName      = "/api.MyAccount/CreateApiKey"
	MyAccount_DisableApiKey_FullMethodName     = "/api.MyAccount/DisableApiKey"
	MyAccount_EnableApiKey_FullMethodName      = "/api.MyAccount/EnableApiKey"
	MyAccount_DeleteApiKey_FullMethodName      = "/api.MyAccount/DeleteApiKey"
	MyAccount_ListApiKeys_FullMethodName       = "/api.MyAccount/ListApiKeys"
	MyAccount_ListMyOrgUnits_FullMethodName    = "/api.MyAccount/ListMyOrgUnits"
	MyAccount_SetDefaultOrgUnit_FullMethodName = "/api.MyAccount/SetDefaultOrgUnit"
	MyAccount_ListMyRegions_FullMethodName     = "/api.MyAccount/ListMyRegions"
	MyAccount_ListMyAzs_FullMethodName         = "/api.MyAccount/ListMyAzs"
)

// MyAccountClient is the client API for MyAccount service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MyAccountClient interface {
	// get my account info
	GetMyInfo(ctx context.Context, in *MyInfoGetReq, opts ...grpc.CallOption) (*MyInfoGetResp, error)
	// get all my active sessions
	GetMySessions(ctx context.Context, in *MySessionsGetReq, opts ...grpc.CallOption) (*MySessionsGetResp, error)
	// logout my active session(/s), if a specific session id is
	// not provided, it will logout all sessions except the current one
	LogoutMySessions(ctx context.Context, in *MySessionsLogoutReq, opts ...grpc.CallOption) (*MySessionsLogoutResp, error)
	// create a new api key for api access
	CreateApiKey(ctx context.Context, in *ApiKeyCreateReq, opts ...grpc.CallOption) (*ApiKeyCreateResp, error)
	// disabling an existing enabled api key, not action is performed
	// if the key is already disabled
	DisableApiKey(ctx context.Context, in *ApiKeyDisableReq, opts ...grpc.CallOption) (*ApiKeyDisableResp, error)
	// enabling an existing disabled api key, not action is performed
	// if the key is already enabled
	EnableApiKey(ctx context.Context, in *ApiKeyEnableReq, opts ...grpc.CallOption) (*ApiKeyEnableResp, error)
	// delete an existing api key
	DeleteApiKey(ctx context.Context, in *ApiKeyDeleteReq, opts ...grpc.CallOption) (*ApiKeyDeleteResp, error)
	// list all available api keys for the user
	ListApiKeys(ctx context.Context, in *ApiKeysListReq, opts ...grpc.CallOption) (*ApiKeysListResp, error)
	// list all Org units available for me
	ListMyOrgUnits(ctx context.Context, in *MyOrgUnitsListReq, opts ...grpc.CallOption) (*MyOrgUnitsListResp, error)
	// set specific Org unit as default access on login
	// relevant only when working with multiple org units
	SetDefaultOrgUnit(ctx context.Context, in *DefaultOrgUnitReq, opts ...grpc.CallOption) (*DefaultOrgUnitResp, error)
	// Get List of available regions for user to work with
	ListMyRegions(ctx context.Context, in *MyRegionsListReq, opts ...grpc.CallOption) (*MyRegionsListResp, error)
	// Get List of availability zones in a given region for the user
	ListMyAzs(ctx context.Context, in *MyAzsListReq, opts ...grpc.CallOption) (*MyAzsListResp, error)
}

type myAccountClient struct {
	cc grpc.ClientConnInterface
}

func NewMyAccountClient(cc grpc.ClientConnInterface) MyAccountClient {
	return &myAccountClient{cc}
}

func (c *myAccountClient) GetMyInfo(ctx context.Context, in *MyInfoGetReq, opts ...grpc.CallOption) (*MyInfoGetResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MyInfoGetResp)
	err := c.cc.Invoke(ctx, MyAccount_GetMyInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *myAccountClient) GetMySessions(ctx context.Context, in *MySessionsGetReq, opts ...grpc.CallOption) (*MySessionsGetResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MySessionsGetResp)
	err := c.cc.Invoke(ctx, MyAccount_GetMySessions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *myAccountClient) LogoutMySessions(ctx context.Context, in *MySessionsLogoutReq, opts ...grpc.CallOption) (*MySessionsLogoutResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MySessionsLogoutResp)
	err := c.cc.Invoke(ctx, MyAccount_LogoutMySessions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *myAccountClient) CreateApiKey(ctx context.Context, in *ApiKeyCreateReq, opts ...grpc.CallOption) (*ApiKeyCreateResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ApiKeyCreateResp)
	err := c.cc.Invoke(ctx, MyAccount_CreateApiKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *myAccountClient) DisableApiKey(ctx context.Context, in *ApiKeyDisableReq, opts ...grpc.CallOption) (*ApiKeyDisableResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ApiKeyDisableResp)
	err := c.cc.Invoke(ctx, MyAccount_DisableApiKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *myAccountClient) EnableApiKey(ctx context.Context, in *ApiKeyEnableReq, opts ...grpc.CallOption) (*ApiKeyEnableResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ApiKeyEnableResp)
	err := c.cc.Invoke(ctx, MyAccount_EnableApiKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *myAccountClient) DeleteApiKey(ctx context.Context, in *ApiKeyDeleteReq, opts ...grpc.CallOption) (*ApiKeyDeleteResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ApiKeyDeleteResp)
	err := c.cc.Invoke(ctx, MyAccount_DeleteApiKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *myAccountClient) ListApiKeys(ctx context.Context, in *ApiKeysListReq, opts ...grpc.CallOption) (*ApiKeysListResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ApiKeysListResp)
	err := c.cc.Invoke(ctx, MyAccount_ListApiKeys_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *myAccountClient) ListMyOrgUnits(ctx context.Context, in *MyOrgUnitsListReq, opts ...grpc.CallOption) (*MyOrgUnitsListResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MyOrgUnitsListResp)
	err := c.cc.Invoke(ctx, MyAccount_ListMyOrgUnits_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *myAccountClient) SetDefaultOrgUnit(ctx context.Context, in *DefaultOrgUnitReq, opts ...grpc.CallOption) (*DefaultOrgUnitResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DefaultOrgUnitResp)
	err := c.cc.Invoke(ctx, MyAccount_SetDefaultOrgUnit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *myAccountClient) ListMyRegions(ctx context.Context, in *MyRegionsListReq, opts ...grpc.CallOption) (*MyRegionsListResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MyRegionsListResp)
	err := c.cc.Invoke(ctx, MyAccount_ListMyRegions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *myAccountClient) ListMyAzs(ctx context.Context, in *MyAzsListReq, opts ...grpc.CallOption) (*MyAzsListResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MyAzsListResp)
	err := c.cc.Invoke(ctx, MyAccount_ListMyAzs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MyAccountServer is the server API for MyAccount service.
// All implementations must embed UnimplementedMyAccountServer
// for forward compatibility.
type MyAccountServer interface {
	// get my account info
	GetMyInfo(context.Context, *MyInfoGetReq) (*MyInfoGetResp, error)
	// get all my active sessions
	GetMySessions(context.Context, *MySessionsGetReq) (*MySessionsGetResp, error)
	// logout my active session(/s), if a specific session id is
	// not provided, it will logout all sessions except the current one
	LogoutMySessions(context.Context, *MySessionsLogoutReq) (*MySessionsLogoutResp, error)
	// create a new api key for api access
	CreateApiKey(context.Context, *ApiKeyCreateReq) (*ApiKeyCreateResp, error)
	// disabling an existing enabled api key, not action is performed
	// if the key is already disabled
	DisableApiKey(context.Context, *ApiKeyDisableReq) (*ApiKeyDisableResp, error)
	// enabling an existing disabled api key, not action is performed
	// if the key is already enabled
	EnableApiKey(context.Context, *ApiKeyEnableReq) (*ApiKeyEnableResp, error)
	// delete an existing api key
	DeleteApiKey(context.Context, *ApiKeyDeleteReq) (*ApiKeyDeleteResp, error)
	// list all available api keys for the user
	ListApiKeys(context.Context, *ApiKeysListReq) (*ApiKeysListResp, error)
	// list all Org units available for me
	ListMyOrgUnits(context.Context, *MyOrgUnitsListReq) (*MyOrgUnitsListResp, error)
	// set specific Org unit as default access on login
	// relevant only when working with multiple org units
	SetDefaultOrgUnit(context.Context, *DefaultOrgUnitReq) (*DefaultOrgUnitResp, error)
	// Get List of available regions for user to work with
	ListMyRegions(context.Context, *MyRegionsListReq) (*MyRegionsListResp, error)
	// Get List of availability zones in a given region for the user
	ListMyAzs(context.Context, *MyAzsListReq) (*MyAzsListResp, error)
	mustEmbedUnimplementedMyAccountServer()
}

// UnimplementedMyAccountServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMyAccountServer struct{}

func (UnimplementedMyAccountServer) GetMyInfo(context.Context, *MyInfoGetReq) (*MyInfoGetResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMyInfo not implemented")
}
func (UnimplementedMyAccountServer) GetMySessions(context.Context, *MySessionsGetReq) (*MySessionsGetResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMySessions not implemented")
}
func (UnimplementedMyAccountServer) LogoutMySessions(context.Context, *MySessionsLogoutReq) (*MySessionsLogoutResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LogoutMySessions not implemented")
}
func (UnimplementedMyAccountServer) CreateApiKey(context.Context, *ApiKeyCreateReq) (*ApiKeyCreateResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateApiKey not implemented")
}
func (UnimplementedMyAccountServer) DisableApiKey(context.Context, *ApiKeyDisableReq) (*ApiKeyDisableResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisableApiKey not implemented")
}
func (UnimplementedMyAccountServer) EnableApiKey(context.Context, *ApiKeyEnableReq) (*ApiKeyEnableResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnableApiKey not implemented")
}
func (UnimplementedMyAccountServer) DeleteApiKey(context.Context, *ApiKeyDeleteReq) (*ApiKeyDeleteResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteApiKey not implemented")
}
func (UnimplementedMyAccountServer) ListApiKeys(context.Context, *ApiKeysListReq) (*ApiKeysListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListApiKeys not implemented")
}
func (UnimplementedMyAccountServer) ListMyOrgUnits(context.Context, *MyOrgUnitsListReq) (*MyOrgUnitsListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMyOrgUnits not implemented")
}
func (UnimplementedMyAccountServer) SetDefaultOrgUnit(context.Context, *DefaultOrgUnitReq) (*DefaultOrgUnitResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDefaultOrgUnit not implemented")
}
func (UnimplementedMyAccountServer) ListMyRegions(context.Context, *MyRegionsListReq) (*MyRegionsListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMyRegions not implemented")
}
func (UnimplementedMyAccountServer) ListMyAzs(context.Context, *MyAzsListReq) (*MyAzsListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMyAzs not implemented")
}
func (UnimplementedMyAccountServer) mustEmbedUnimplementedMyAccountServer() {}
func (UnimplementedMyAccountServer) testEmbeddedByValue()                   {}

// UnsafeMyAccountServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MyAccountServer will
// result in compilation errors.
type UnsafeMyAccountServer interface {
	mustEmbedUnimplementedMyAccountServer()
}

func RegisterMyAccountServer(s grpc.ServiceRegistrar, srv MyAccountServer) {
	// If the following call pancis, it indicates UnimplementedMyAccountServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MyAccount_ServiceDesc, srv)
}

func _MyAccount_GetMyInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MyInfoGetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MyAccountServer).GetMyInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MyAccount_GetMyInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MyAccountServer).GetMyInfo(ctx, req.(*MyInfoGetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MyAccount_GetMySessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MySessionsGetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MyAccountServer).GetMySessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MyAccount_GetMySessions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MyAccountServer).GetMySessions(ctx, req.(*MySessionsGetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MyAccount_LogoutMySessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MySessionsLogoutReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MyAccountServer).LogoutMySessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MyAccount_LogoutMySessions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MyAccountServer).LogoutMySessions(ctx, req.(*MySessionsLogoutReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MyAccount_CreateApiKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiKeyCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MyAccountServer).CreateApiKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MyAccount_CreateApiKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MyAccountServer).CreateApiKey(ctx, req.(*ApiKeyCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MyAccount_DisableApiKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiKeyDisableReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MyAccountServer).DisableApiKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MyAccount_DisableApiKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MyAccountServer).DisableApiKey(ctx, req.(*ApiKeyDisableReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MyAccount_EnableApiKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiKeyEnableReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MyAccountServer).EnableApiKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MyAccount_EnableApiKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MyAccountServer).EnableApiKey(ctx, req.(*ApiKeyEnableReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MyAccount_DeleteApiKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiKeyDeleteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MyAccountServer).DeleteApiKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MyAccount_DeleteApiKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MyAccountServer).DeleteApiKey(ctx, req.(*ApiKeyDeleteReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MyAccount_ListApiKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiKeysListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MyAccountServer).ListApiKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MyAccount_ListApiKeys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MyAccountServer).ListApiKeys(ctx, req.(*ApiKeysListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MyAccount_ListMyOrgUnits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MyOrgUnitsListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MyAccountServer).ListMyOrgUnits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MyAccount_ListMyOrgUnits_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MyAccountServer).ListMyOrgUnits(ctx, req.(*MyOrgUnitsListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MyAccount_SetDefaultOrgUnit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DefaultOrgUnitReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MyAccountServer).SetDefaultOrgUnit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MyAccount_SetDefaultOrgUnit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MyAccountServer).SetDefaultOrgUnit(ctx, req.(*DefaultOrgUnitReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MyAccount_ListMyRegions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MyRegionsListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MyAccountServer).ListMyRegions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MyAccount_ListMyRegions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MyAccountServer).ListMyRegions(ctx, req.(*MyRegionsListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MyAccount_ListMyAzs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MyAzsListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MyAccountServer).ListMyAzs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MyAccount_ListMyAzs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MyAccountServer).ListMyAzs(ctx, req.(*MyAzsListReq))
	}
	return interceptor(ctx, in, info, handler)
}

// MyAccount_ServiceDesc is the grpc.ServiceDesc for MyAccount service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MyAccount_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.MyAccount",
	HandlerType: (*MyAccountServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetMyInfo",
			Handler:    _MyAccount_GetMyInfo_Handler,
		},
		{
			MethodName: "GetMySessions",
			Handler:    _MyAccount_GetMySessions_Handler,
		},
		{
			MethodName: "LogoutMySessions",
			Handler:    _MyAccount_LogoutMySessions_Handler,
		},
		{
			MethodName: "CreateApiKey",
			Handler:    _MyAccount_CreateApiKey_Handler,
		},
		{
			MethodName: "DisableApiKey",
			Handler:    _MyAccount_DisableApiKey_Handler,
		},
		{
			MethodName: "EnableApiKey",
			Handler:    _MyAccount_EnableApiKey_Handler,
		},
		{
			MethodName: "DeleteApiKey",
			Handler:    _MyAccount_DeleteApiKey_Handler,
		},
		{
			MethodName: "ListApiKeys",
			Handler:    _MyAccount_ListApiKeys_Handler,
		},
		{
			MethodName: "ListMyOrgUnits",
			Handler:    _MyAccount_ListMyOrgUnits_Handler,
		},
		{
			MethodName: "SetDefaultOrgUnit",
			Handler:    _MyAccount_SetDefaultOrgUnit_Handler,
		},
		{
			MethodName: "ListMyRegions",
			Handler:    _MyAccount_ListMyRegions_Handler,
		},
		{
			MethodName: "ListMyAzs",
			Handler:    _MyAccount_ListMyAzs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "myaccount.proto",
}
